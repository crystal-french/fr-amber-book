# Websockets

Websockets allow full-duplex instant communication between clients, for solutions such as chat or other forms of real time communication. The websockets amber websockets API is very simple, and only requires a Socket, a Channel, and client side interaction using javascript.



#### Channels

Users will subscribe and unsubscribe from channels. Channels define 3 public methods that can be used:

* `handle_joined` - Called when a user joins a channel
* `handle_message` - Called when a user sends a message to a channel.  A common message handler will simply rebroadcast the message to the other subscribers with `rebroadcast!` method.
* `handle_leave` - Called when a user leaves the channel.

A channel can be generated by calling `amber g channel ChatChannel`

```ruby
class ChatRoomChannel < Amber::Websockets::Channel

  # optional
  # Authorization can happen here  
  def handle_joined(socket, message)
    # channel join related functionality
    if socket.session[:user_id] != message["payload"]["user_id"]
      socket.disconnect!
    end
  end

  # required
  def handle_message(msg)
    rebroadcast!(msg)
  end

  # optional
  def handle_leave
    # channel leave functionality    
  end
end
```

#### Sockets

Socket structs are the object that is stored in memory per connection and retain the persistent communication. Sockets define one public method on\_connect which can contain functionality that should run when a user connects, including authentication.  This methods should return a Bool. If `true`  the socket will remain open.  If `false` the socket will be closed immediately.

Socket structs also map topics to the channels they will connect with.

A socket can be generated by calling `amber g socket UserSocket`

```ruby
struct UserSocket < Amber::WebSockets::ClientSocket
  channel "chat_room:*", ChatRoomChannel

  def on_connect
    # do authentication here
    !session[:user_id].nil?
  end
end
```



